#!/bin/sh

fatal() {
	echo "error: $1" >&2
	exit 1
}

basepath="/var/potatofs"
mountpoint="/mnt/potatofs"

datapath="$basepath/data"
binpath=$HOME/potatofs/bin
conf="$HOME/potatofs/config"
pidfile=$basepath/potatomgr.pid

[ -d "$mountpoint" ] || fatal "mountpoint not found"
[ -d "$basepath" ] || fatal "base dir not found"
[ -x $binpath/potatofs ] || fatal "potatofs is not found or executable"
[ -x $binpath/potatoctl ] || fatal "potatoctl is not found or executable"
[ -x $binpath/potatomgr ] || fatal "potatomgr is not found or executable"

mkdir -p $datapath
ulimit -n 4096

case $1 in
	start)
		echo -n "* Starting potatomgr..."
		$binpath/potatomgr -c $conf
		echo "OK."

		# TODO: we need to make sure fsck doesn't update the slabs
		# that it downloads, and doesn't update last_claimed so that
		# they can quickly be purged as we loop over them to
		# compute their checksum.
		#
		# We also need a "fast" fsck mode that only validates inodes,
		# so that we can leave the file slabs alone.
		echo -n "* fsck"
		$binpath/potatoctl -c $conf fsck quiet || exit 1
		echo ""

		echo "* Mounting..."
		$binpath/potatofs -o cfg_path=$conf,max_open_slabs=2048 \
			$mountpoint
		;;
	stop)
		echo -n "* Starting potatofs/potatomgr..."
		fusermount -u $mountpoint
		while pgrep -f -l "$mountpoint" >/dev/null; do
			echo -n "."
			sleep 1
		done
		pid=`cat $pidfile`
		$binpath/potatoctl -c $conf shutdown
		while $binpath/potatoctl -c $conf status >/dev/null 2>&1; do
			echo -n "."
			sleep 1
		done
		# TODO: we still need this since the 'status' command above
		# will not be able to use workers, which at this point
		# will be down.
		while kill -0 "$pid"; do sleep 1; done
		echo "OK."
		;;
	*)
		echo "Usage: $(basename $0) <start|stop>"
		;;
esac

exit $?
