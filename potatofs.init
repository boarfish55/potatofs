#!/bin/sh

fatal() {
	echo "error: $1" >&2
	exit 1
}

basepath="/var/potatofs"
mountpoint="/mnt/potatofs"

datapath="$basepath/data"
binpath=$HOME/potatofs/bin
conf="$HOME/potatofs/config"
pidfile=$basepath/potatomgr.pid

[ -d "$mountpoint" ] || fatal "mountpoint not found"
[ -d "$basepath" ] || fatal "base dir not found"
[ -x $binpath/potatofs ] || fatal "potatofs is not found or executable"
[ -x $binpath/potatoctl ] || fatal "potatoctl is not found or executable"
[ -x $binpath/potatomgr ] || fatal "potatomgr is not found or executable"

mkdir -p $datapath
ulimit -n 4096

case $1 in
	start)
		echo -n "* Starting potatomgr..."
		$binpath/potatomgr -c $conf -p $pidfile
		echo "OK."

		# TODO: we need to make sure fsck doesn't update the slabs
		# that it downloads, and doesn't update last_claimed so that
		# they can quickly be purged as we loop over them to
		# compute their checksum.
		#
		# We also need a "fast" fsck mode that only validates inodes,
		# so that we can leave the file slabs alone.
		#echo -n "* fsck"
		#$binpath/potatoctl -c $conf fsck
		#echo ""

		echo "* Mounting..."
		$binpath/potatofs -o cfg_path=$conf,max_open_slabs=2048 \
			$mountpoint
		;;
	stop)
		fusermount -u $mountpoint
		# TODO: change this once we get a pid file or a control
		# socket.
		while pgrep -f -l "$mountpoint" >/dev/null; do sleep 1; done
		pid=`cat $pidfile`
		kill "$pid"
		while kill -0 "$pid"; do sleep 1; done
		;;
	*)
		echo "Usage: $(basename $0) <start|stop>"
		;;
esac

exit $?
